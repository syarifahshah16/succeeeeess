#!/usr/bin/env python
# -*- coding: ISO-8859-1 -*-
#
# generated by wxGlade 0.8.3 on Mon Dec  3 04:48:04 2018
#

import wx
import os
import sys  # We need sys so that we can pass argv to QApplication
from subprocess import Popen, PIPE
import dpkt
import datetime, time
import socket
from wx.lib.wordwrap import wordwrap
import wx.lib.agw.ultimatelistctrl as ULC





# begin wxGlade: dependencies
# end wxGlade

# begin wxGlade: extracode
# end wxGlade


class mainNetAnalysis(wx.Frame):
      def __init__(self, *args, **kwds):
            # begin wxGlade: mainNetAnalysis.__init__
            kwds["style"] = kwds.get("style", 0) | wx.DEFAULT_FRAME_STYLE
            wx.Frame.__init__(self, *args, **kwds)
            self.SetSize((1950, 873))
            
            # Menu Bar
            self.mainNetAnalysis_menubar = wx.MenuBar()
            wxglade_tmp_menu = wx.Menu()
            self.mainNetAnalysis_menubar.i_uploadpcap = wxglade_tmp_menu.Append(wx.ID_ANY, "Open Pcap", "")
            self.Bind(wx.EVT_MENU, self.on_menu_upload_PCAP, id=self.mainNetAnalysis_menubar.i_uploadpcap.GetId())
            item = wxglade_tmp_menu.Append(wx.ID_ANY, "Process HTML Report", "")
            self.Bind(wx.EVT_MENU, self.on_html_report, id=item.GetId())
            item = wxglade_tmp_menu.Append(wx.ID_ANY, "Exit", "")
            self.Bind(wx.EVT_MENU, self.on_menu_File_Exit, id=item.GetId())
            self.mainNetAnalysis_menubar.Append(wxglade_tmp_menu, "File")
            wxglade_tmp_menu = wx.Menu()
            item = wxglade_tmp_menu.Append(wx.ID_ANY, "Clear GUI", "")
            self.Bind(wx.EVT_MENU, self.on_tools_clear, id=item.GetId())
            item = wxglade_tmp_menu.Append(wx.ID_ANY, "Delete Data", "")
            self.Bind(wx.EVT_MENU, self.on_tools_del, id=item.GetId())
            self.mainNetAnalysis_menubar.Append(wxglade_tmp_menu, "Tools")
            self.SetMenuBar(self.mainNetAnalysis_menubar)
            # Menu Bar end
            self.mainNetAnalysis_statusbar = self.CreateStatusBar(1, wx.STB_DEFAULT_STYLE | wx.STB_ELLIPSIZE_MIDDLE | wx.STB_ELLIPSIZE_START)
            self.packet_details_copy = wx.Notebook(self, wx.ID_ANY)
            self.packet_details_copy_pane_2 = wx.Panel(self.packet_details_copy, wx.ID_ANY)
            self.pcaplist = wx.ListCtrl(self.packet_details_copy_pane_2, wx.ID_ANY, style=wx.LC_HRULES | wx.LC_REPORT | wx.LC_SINGLE_SEL | wx.LC_VRULES)
            self.packetsList = wx.TextCtrl(self.packet_details_copy_pane_2, wx.ID_ANY, "", style=wx.TE_MULTILINE | wx.TE_READONLY)
            self.packet_details_copy_Protocol = wx.Panel(self.packet_details_copy, wx.ID_ANY)
            self.dnslist = wx.ListCtrl(self.packet_details_copy_Protocol, wx.ID_ANY, style=wx.LC_HRULES | wx.LC_REPORT | wx.LC_SINGLE_SEL | wx.LC_VRULES)

            self.__set_properties()
            self.__do_layout()

            
            # end wxGlade

      def __set_properties(self):
            # begin wxGlade: mainNetAnalysis.__set_properties
            self.SetTitle("Network Analysis (NO TCPDUMP)")
            self.SetBackgroundColour(wx.Colour(232, 232, 232))
            self.mainNetAnalysis_statusbar.SetStatusWidths([-1])

            # statusbar fields
            mainNetAnalysis_statusbar_fields = ["Network Analysis"]
            for i in range(len(mainNetAnalysis_statusbar_fields)):
                  self.mainNetAnalysis_statusbar.SetStatusText(mainNetAnalysis_statusbar_fields[i], i)
            self.pcaplist.SetMinSize((1950, 370))
            self.packetsList.SetMinSize((1950, 370))
            self.packetsList.SetBackgroundColour(wx.Colour(211, 211, 211))
            self.pcaplist.AppendColumn("Packet", format=wx.LIST_FORMAT_LEFT, width=70)
            self.pcaplist.AppendColumn("Time", format=wx.LIST_FORMAT_LEFT, width=200)
            self.pcaplist.AppendColumn("Source", format=wx.LIST_FORMAT_LEFT, width=193)
            self.pcaplist.AppendColumn("Destination", format=wx.LIST_FORMAT_LEFT, width=193)
            self.pcaplist.AppendColumn("HTTP Request", format=wx.LIST_FORMAT_LEFT, width=wx.LIST_AUTOSIZE)
            self.dnslist.AppendColumn("DNS", format=wx.LIST_FORMAT_LEFT, width=185)
            self.dnslist.AppendColumn("IP Response", format=wx.LIST_FORMAT_LEFT, width=193)
            self.dnslist.AppendColumn("Protocol", format=wx.LIST_FORMAT_LEFT, width=193)

            # end wxGlade

      def __do_layout(self):
            # begin wxGlade: mainNetAnalysis.__do_layout
            sizer_1 = wx.BoxSizer(wx.VERTICAL)
            sizer_4 = wx.BoxSizer(wx.VERTICAL)
            sizer_5 = wx.BoxSizer(wx.VERTICAL)
            sizer_4.Add(self.pcaplist, 0, wx.BOTTOM, 0)
            sizer_4.Add(self.packetsList, 0, wx.TOP, 27)
            self.packet_details_copy_pane_2.SetSizer(sizer_4)
            sizer_5.Add(self.dnslist, 1, wx.EXPAND, 0)
            self.packet_details_copy_Protocol.SetSizer(sizer_5)
            self.packet_details_copy.AddPage(self.packet_details_copy_pane_2, "Sessions")
            self.packet_details_copy.AddPage(self.packet_details_copy_Protocol, "DNS")
            sizer_1.Add(self.packet_details_copy, 1, wx.EXPAND, 0)
            self.SetSizer(sizer_1)
            self.Layout()
            self.Centre()
            # end wxGlade

      def addPCAPDetails(self, row):
        self.pcaplist.Append(row)


      def addDNSDetails(self, row2):
        self.dnslist.Append(row2)


      def inet_to_str(inet):
        """Convert inet object to a string

        Args:
            inet (inet struct): inet network address
        Returns:
            str: Printable/readable IP address"""
    # First try ipv4 and then ipv6
        try:
            return socket.inet_ntop(socket.AF_INET, inet)
        except ValueError:
            return socket.inet_ntop(socket.AF_INET6, inet)


      def on_menu_upload_PCAP(self, event):  # wxGlade: MyFrame.<event_handler>
            openFileDialog = wx.FileDialog(self, "Open", "", "","*.pcap",     #creates a filedialog that only allow user to select .pcap files 
                                        wx.FD_OPEN | wx.FD_FILE_MUST_EXIST)

            if openFileDialog.ShowModal() == wx.ID_OK:
                  global filename
                  evidencePath = openFileDialog.GetPath()                         #get path of selected pcap file
                  filename = os.path.basename(evidencePath)
                  f = open(evidencePath, 'rb')
                  pcap = dpkt.pcap.Reader(f)
                  # For each packet in the pcap process the contents
                  identifier = 0
                  for timestamp, buf in pcap:

                    """# Print out the timestamp in UTC
                    print ("Timestamp" , str(datetime.datetime.utcfromtimestamp(timestamp)))"""
                    
                    identifier = identifier + 1
                    Packet  = identifier

                    # Unpack the Ethernet frame (mac src/dst, ethertype)
                    eth = dpkt.ethernet.Ethernet(buf)
                    """print ('Ethernet Frame: ', mac_addr(eth.src), mac_addr(eth.dst), eth.type)"""

                    # Make sure the Ethernet frame contains an IP packet
                    if not isinstance(eth.data, dpkt.ip.IP):
                        print ('Non IP Packet type not supported %s\n' % eth.data.__class__.__name__)
                        continue

                    # Now unpack the data within the Ethernet frame (the IP packet)
                    # Pulling out src, dst, length, fragment info, TTL, and Protocol
                    ip_hdr = eth.data

                    # Check for TCP in the transport layer
                    if isinstance(ip_hdr.data, dpkt.tcp.TCP):

                        # Set the TCP data
                        tcp = ip_hdr.data

                        # Now see if we can parse the contents as a HTTP request
                        try:
                            request = dpkt.http.Request(tcp.data)
                        except (dpkt.dpkt.NeedData, dpkt.dpkt.UnpackError):
                            continue

                        # Pull out fragment information (flags and offset all packed into off field, so use bitmasks)
                        """do_not_fragment = bool(ip.off & dpkt.ip.IP_DF)
                        more_fragments = bool(ip.off & dpkt.ip.IP_MF)
                        fragment_offset = ip.off & dpkt.ip.IP_OFFMASK"""



                    """# Pull out fragment information (flags and offset all packed into off field, so use bitmasks)
                    do_not_fragment = bool(ip.off & dpkt.ip.IP_DF)
                    more_fragments = bool(ip.off & dpkt.ip.IP_MF)
                    fragment_offset = ip.off & dpkt.ip.IP_OFFMASK

                    # Print out the info
                    print ('IP: %s -> %s   (len=%d ttl=%d DF=%d MF=%d offset=%d)\n' )% \
                    (inet_to_str(ip.src), inet_to_str(ip.dst), ip.len, ip.ttl, do_not_fragment, more_fragments, fragment_offset)"""

                    #pulling out the source ip from the eth.data
                    src_ip_addr_bin = ip_hdr.src
                    #conversion to readable (i think)
                    src_ip = socket.inet_ntoa(src_ip_addr_bin)

                    #pulling out the dest ip from the eth.data
                    dst_ip_addr_bin = ip_hdr.dst
                    #conversion to readable (i think)
                    dst_ip = socket.inet_ntoa(dst_ip_addr_bin)

                    #puling out the protocol
                    proto = ip_hdr.get_proto(ip_hdr.p).__name__


                    #order of arrangement inserted into the ListCtrl (pcaplist)
                    row = [Packet, str(datetime.datetime.utcfromtimestamp(timestamp)), src_ip, dst_ip, repr(request)]
                    mainNetAnalysis.addPCAPDetails(self, row)


                    #tcpdump in the bottom half of sessions (data dump with hex)
                    #cmd = ['sudo', 'tcpdump', '-qns', '0', '-x', '-r', filename]
                    #process = Popen(cmd, stdout=PIPE, stderr=PIPE)
                    #stdout, stderr = process.communicate()
                    #self.packetsList.SetValue(stdout)

                    #DNS PORTION (dnslist)
                    #make sure we are dealing with IP traffic
                    try:
                        eth = dpkt.ethernet.Ethernet(buf)
                    except:
                        continue
                    if eth.type != 2048:
                        continue
                    #make sure we are dealing with UDP protocol
                    try:
                        ip = eth.data
                    except:
                        continue
                    if ip.p != 17:
                        continue
                    #filter on UDP assigned ports for DNS
                    try:
                        udp = ip.data
                    except:
                        continue
                    if udp.sport != 53 and udp.dport != 53:
                        continue
                    #make the dns object out of the udp data and
                    #check for it being a RR (answer) and for opcode QUERY
                    try:
                        dns = dpkt.dns.DNS(udp.data)
                    except:
                        continue
                    if dns.qr != dpkt.dns.DNS_R:
                        continue
                    if dns.opcode != dpkt.dns.DNS_QUERY:
                        continue
                    if dns.rcode != dpkt.dns.DNS_RCODE_NOERR:
                        continue
                    if len(dns.an) < 1:
                        continue
                    #process and print responses based on record type
                    for answer in dns.an:
                        if answer.type == 1: #DNS_A
                              row2 = [answer.name, socket.inet_ntoa(answer.rdata), proto]
                              mainNetAnalysis.addDNSDetails(self, row2)


                  print("PCAP Uploaded")

            else: 
                  print("Error Occurred!")


      def on_html_report(self, event):  # wxGlade: mainNetAnalysis.<event_handler>
            global filename
            directoryfiledialog = wx.DirDialog (None, "Choose directory", "",
                                    wx.DD_DEFAULT_STYLE | wx.DD_DIR_MUST_EXIST)
            if directoryfiledialog.ShowModal() == wx.ID_OK:
                creaderpath = directoryfiledialog.GetPath()                         #get path of selected directory
                directoryname = os.path.basename(creaderpath)                       #get directory name

                crd = ['chaosreader', filename, '--dir', directoryname]             #run the chaosreader cmd
                process = Popen(crd, stdout=PIPE, stderr=PIPE)
                stdout, stderr = process.communicate()

                print("Report successfully made in " +creaderpath) #print out full path so that user knows exactly where the directory is



      def on_menu_File_Exit(self, event):  # wxGlade: mainNetAnalysis.<event_handler>
            self.Destroy()

      def on_tools_clear(self, event):  # wxGlade: mainNetAnalysis.<event_handler>
            print("Event handler 'on_tools_clear' not implemented!")
            event.Skip()

      def on_tools_del(self, event):  # wxGlade: mainNetAnalysis.<event_handler>
            print("Event handler 'on_tools_del' not implemented!")
            event.Skip()


      def itemSelectionChanged(self, event):  # wxGlade: mainNetAnalysis.<event_handler>
            print("Event handler 'itemSelectionChanged' not implemented!")
            event.Skip()






# end of class mainNetAnalysis

class MyApp(wx.App):
      def OnInit(self):
            self.mainNetAnalysis = mainNetAnalysis(None, wx.ID_ANY, "")
            self.SetTopWindow(self.mainNetAnalysis)
            self.mainNetAnalysis.Show()
            return True

# end of class MyApp

if __name__ == "__main__":
      app = MyApp(0)
      app.MainLoop()


