#!/usr/bin/env python
# -*- coding: UTF-8 -*-
#
# generated by wxGlade 0.8.3 on Fri Aug 31 03:44:54 2018
#

import wx
import wx.aui
import os
import random
import SummaryTab, pcapFilesTab, NewCaseDialog, mainmenu, search, searchTab, pcapSessionsTab, pcapDNSTab, pcapCredentialsTab         
import connectdb
import subprocess
import sqlite3
from sqlite3 import Error
from pathlib import Path
import datetime, time
import re
import threading

# relating to extraction of values from PCAP file
# see https://pypi.org/project/dpkt/
import dpkt
from dpkt.ip import IP
from dpkt.ethernet import Ethernet
from dpkt.arp import ARP
import datetime, time

import struct
import socket



# begin wxGlade: dependencies
# end wxGlade

# begin wxGlade: extracode
# end wxGlade

openTabs = [0]

class mainFrame(wx.Frame):
    def __init__(self, parent):
        # begin wxGlade: mainFrame.__init__
        wx.Frame.__init__(self, parent=parent)
        self.SetSize((1280, 720))
        
        # Menu Bar
        self.frame_menubar = wx.MenuBar()
        wxglade_tmp_menu = wx.Menu()
        item = wxglade_tmp_menu.Append(wx.ID_ANY, "New case", "")
        self.Bind(wx.EVT_MENU, self.onNewCase, id=item.GetId())
        item = wxglade_tmp_menu.Append(wx.ID_ANY, "Open case", "")
        self.Bind(wx.EVT_MENU, self.onOpenCase, id=item.GetId())
        wxglade_tmp_menu.AppendSeparator()
        itemAddEvidenceBtn = wxglade_tmp_menu.Append(wx.ID_ANY, "Add PCAP File", "")                                      
        self.Bind(wx.EVT_MENU, self.onAddEvidence, id=itemAddEvidenceBtn.GetId())     
        wxglade_tmp_menu.AppendSeparator()
        item = wxglade_tmp_menu.Append(wx.ID_ANY, "Quit", "")
        self.Bind(wx.EVT_MENU, self.onQuit, id=item.GetId())
        self.frame_menubar.Append(wxglade_tmp_menu, "File")
        wxglade_tmp_menu = wx.Menu()
        item = wxglade_tmp_menu.Append(wx.ID_ANY, "Clear GUI", "")
        self.Bind(wx.EVT_MENU, self.onClearGUI, id=item.GetId())
        item = wxglade_tmp_menu.Append(wx.ID_ANY, "Delete Data", "")
        self.Bind(wx.EVT_MENU, self.onDeleteData, id=item.GetId())
        
        """item = wxglade_tmp_menu.Append(wx.ID_ANY, "Network pcap files", "")
        self.Bind(wx.EVT_MENU, self.onSelNetworkPcapFiles, id=item.GetId())"""

        self.frame_menubar.Append(wxglade_tmp_menu, "Tools")
        self.SetMenuBar(self.frame_menubar)
        # Menu Bar end

        #splitter window
        self.window_1 = wx.SplitterWindow(self, wx.ID_ANY)

        #left panel
        self.windowLeftPanel = wx.Panel(self.window_1, wx.ID_ANY)
        self.tree_ctrl_1 = wx.TreeCtrl(self.windowLeftPanel, wx.ID_ANY, style=wx.TR_HAS_BUTTONS | wx.TR_MULTIPLE)
        
        #right panel
        self.windowRightPanel = wx.Panel(self.window_1, wx.ID_ANY)
        self.searchBtn = wx.Button(self.windowRightPanel, id=wx.ID_ANY, label="Search", pos=wx.DefaultPosition, size=(100,-1), style=0, validator=wx.DefaultValidator)
       
        mainFrame.auiNotebook = wx.aui.AuiNotebook(self.windowRightPanel)
        self.paneltest = wx.Panel(mainFrame.auiNotebook, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.TAB_TRAVERSAL)
        
    
        #bind events
        self.Bind(wx.EVT_TREE_ITEM_ACTIVATED, self.onItemSel, self.tree_ctrl_1)
        self.Bind(wx.EVT_BUTTON, self.onSearchBtn, self.searchBtn)
        self.Bind(wx.aui.EVT_AUINOTEBOOK_PAGE_CLOSE, self.onAuiClose, mainFrame.auiNotebook)

        #properties
        self.SetTitle("Forensic Pi")
        self.tree_ctrl_1.SetBackgroundColour(wx.Colour(240, 240, 240))
        self.windowLeftPanel.SetMinSize((180, -1))
        self.windowRightPanel.SetMinSize((980, -1))
        self.window_1.SetMinimumPaneSize(20)

        #layout
        mainSizer = wx.BoxSizer(wx.VERTICAL)
        
        #left panel sizer
        panel1Sizer = wx.BoxSizer(wx.HORIZONTAL)
        panel1Sizer.Add(self.tree_ctrl_1, 1, wx.EXPAND, 0)
        self.windowLeftPanel.SetSizer(panel1Sizer)
        
        #right panel sizer
        self.panel2Sizer = wx.BoxSizer(wx.VERTICAL)
        self.panel2Sizer.Add(self.searchBtn, 0, wx.ALIGN_RIGHT , 0)
        self.panel2Sizer.Add(mainFrame.auiNotebook, 1, wx.EXPAND, 0)
        self.windowRightPanel.SetSizer(self.panel2Sizer)
        
        #splitter
        self.window_1.SplitVertically(self.windowLeftPanel, self.windowRightPanel)
        mainSizer.Add(self.window_1, 1, wx.EXPAND, 0)
       
        self.SetSizer(mainSizer)
        self.Layout()


    def recreateTree(self, caseDbFile):
        self.tree_ctrl_1.Freeze()
        self.tree_ctrl_1.DeleteAllItems()
        global caseName
        for x in caseDetails:
            caseName = str(x[2]) + "_" + x[3]

        root = self.tree_ctrl_1.AddRoot(caseName)                                   #adds the name of case as root item in treectrl
        self.tree_ctrl_1.AppendItem(root, "Summary")
       
        conn = connectdb.create_connection(caseDbFile)                              #connect to case database
        evidenceInfo = connectdb.select_evidence_details(conn)                      #get evidenceName, EvidenceDbPath EvidenceDatetime and Md5 from case database
                                                                                    #EvidenceDbPath = path to tsk database generated when onAddEvidence is called
        self.tree_ctrl_1.AppendItem(root, "Bookmarks")
        self.tree_ctrl_1.AppendItem(root, "File")
        self.tree_ctrl_1.AppendItem(root, "Images")
        self.tree_ctrl_1.AppendItem(root, "Sessions")
        self.tree_ctrl_1.AppendItem(root, "DNS")
        self.tree_ctrl_1.AppendItem(root, "Credentials")

        self.tree_ctrl_1.ExpandAll()
        self.tree_ctrl_1.Thaw()

    #menu functions
    def onNewCase(self, event):  
        dialog = NewCaseDialog.newCase(None)
        dialog.Center()
        dialog.ShowModal()
        dbPath = dialog.getCaseDb()
        
        global caseDetails
        try:
            conn = connectdb.create_connection(dbPath)                      #connects to new case database
            caseDetails = connectdb.select_case_details(conn)               #get InvestigatorName, CaseNum, CaseName, CaseFolder, CaseDb, CaseDesc, Datatime from case database
            self.recreateTree(dbPath)                                       #creates treectrl
        except:
            pass 
        
        dialog.Destroy()
        

    def onOpenCase(self, event):  
        openFileDialog = wx.FileDialog(self, "Open", "", "","*.db",         #creates a filedialog that only allow user to select .db files
                                       wx.FD_OPEN | wx.FD_FILE_MUST_EXIST) 
 
        openFileDialog.ShowModal()                      
        global caseDbPath
        caseDbPath  = openFileDialog.GetPath()                              #get path selected in filedialog
        
        global caseDetails, evidenceDetails
        try:
            conn = connectdb.create_connection(caseDbPath)                  #try to connect to case database and get case and evidence details
            caseDetails = connectdb.select_case_details(conn)
            evidenceDetails = connectdb.select_evidence_details(conn)       #get EvidenceName, EvidenceDbPath, EvidenceDatatime and Md5 from case database
            self.addAuiTab("Summary", evidenceDetails)                      #opens summary page 
            openTabs.append("Summary")                          
            self.recreateTree(caseDbPath)
        except:
            pass                                                            #ignore if try: fails
        openFileDialog.Destroy()


    def runsessions(lock):
        lock.acquire()
        global evidencePath
        # Find the window corresponding to the File tab so that we can
        # access it
        pageCount = mainFrame.auiNotebook.GetPageCount()
        found = False
        print("Page count: ", pageCount)
        #must initialize the page count on top so i can use here to match the text
        for i in range (0, pageCount): # 0 to pageCount - 1
            text = mainFrame.auiNotebook.GetPageText(i)
            print("Page ", i, ": ", text, ";")
            if text == "Sessions":
                window = mainFrame.auiNotebook.GetPage(i)
                found = True
                break # from for-loop

        if False == found:
            print("ERROR: Tab window not found!")
            return # can't continue with this function                    
            
        #rb is for opening non-text files
        f = open(evidencePath, 'rb')
        pcap = dpkt.pcap.Reader(f)

        # For each packet in the pcap process the contents
        identifier = 0
        for timestamp, buf in pcap:

            """# Print out the timestamp in UTC
            print ("Timestamp" , str(datetime.datetime.utcfromtimestamp(timestamp)))"""
                    
            identifier = identifier + 1
            Packet  = identifier

            # Unpack the Ethernet frame (mac src/dst, ethertype)
            eth = dpkt.ethernet.Ethernet(buf)
            """print ('Ethernet Frame: ', mac_addr(eth.src), mac_addr(eth.dst), eth.type)"""

            # Make sure the Ethernet frame contains an IP packet
            if not isinstance(eth.data, dpkt.ip.IP):
                print ('Non IP Packet type not supported %s\n' % eth.data.__class__.__name__)
                continue

            # Now unpack the data within the Ethernet frame (the IP packet)
            # Pulling out src, dst, length, fragment info, TTL, and Protocol
            ip_hdr = eth.data

            # Check for TCP in the transport layer
            if isinstance(ip_hdr.data, dpkt.tcp.TCP):

                # Set the TCP data
                tcp = ip_hdr.data

                # Now see if we can parse the contents as a HTTP request
                try:
                    request = dpkt.http.Request(tcp.data)
                except (dpkt.dpkt.NeedData, dpkt.dpkt.UnpackError):
                    continue

            #pulling out the source ip from the eth.data
            src_ip_addr_bin = ip_hdr.src
            #conversion to readable (i think)
            src_ip = socket.inet_ntoa(src_ip_addr_bin)

            #pulling out the dest ip from the eth.data
            dst_ip_addr_bin = ip_hdr.dst
            #conversion to readable (i think)
            dst_ip = socket.inet_ntoa(dst_ip_addr_bin)

            #puling out the protocol
            proto = ip_hdr.get_proto(ip_hdr.p).__name__

            sequence = [str(Packet), str(datetime.datetime.utcfromtimestamp(timestamp)), str(src_ip), str(dst_ip), str(request)]
            pcapSessionsTab.SessionsTabPanel.addSessionsDetails(window, sequence)
        lock.release()

  
    def rundns(lock):
        lock.acquire()
        global evidencePath

        pageCount = mainFrame.auiNotebook.GetPageCount()
        found = False
        print("Page count: ", pageCount)
        for i in range (0, pageCount): # 0 to pageCount - 1
            text = mainFrame.auiNotebook.GetPageText(i)
            print("Page ", i, ": ", text, ";")

            if text == "DNS":
                window = mainFrame.auiNotebook.GetPage(i)
                found = True
                break # from for-loop

        #rb is for opening non-text files
        f = open(evidencePath, 'rb')
        pcap = dpkt.pcap.Reader(f)

        for timestamp, buf in pcap:

            try:
                eth = dpkt.ethernet.Ethernet(buf)
            except:
                continue
            if eth.type != 2048:
                continue
            #make sure we are dealing with UDP protocol
            try:
                ip = eth.data
            except:
                continue
            if ip.p != 17:
                continue
            #filter on UDP assigned ports for DNS
            try:
                udp = ip.data
            except:
                continue
            if udp.sport != 53 and udp.dport != 53:
                continue
            #make the dns object out of the udp data and
            #check for it being a RR (answer) and for opcode QUERY
            try:
                dns = dpkt.dns.DNS(udp.data)
            except:
                continue
            if dns.qr != dpkt.dns.DNS_R:
                continue
            if dns.opcode != dpkt.dns.DNS_QUERY:
                continue
            if dns.rcode != dpkt.dns.DNS_RCODE_NOERR:
                continue
            if len(dns.an) < 1:
                continue
            #process and print responses based on record type
            #puling out the protocol
            proto = ip.get_proto(ip.p).__name__

            for answer in dns.an:
                if answer.type == 1: #DNS_A
                    row2 = [str(answer.name), str(socket.inet_ntoa(answer.rdata)), str(proto)]
                    pcapDNSTab.DNSTabPanel.addDNSDetails(window, row2)
        lock.release()


    def runCred(lock):
        lock.acquire()
        global evidencePath
        # Find the window corresponding to the File tab so that we can
        # access it
        pageCount = mainFrame.auiNotebook.GetPageCount()
        found = False
        print("Page count: ", pageCount)
        #must initialize the page count on top so i can use here to match the text
        for i in range (0, pageCount): # 0 to pageCount - 1
            text = mainFrame.auiNotebook.GetPageText(i)
            print("Page ", i, ": ", text, ";")
            if text == "Credentials":
                window = mainFrame.auiNotebook.GetPage(i)
                found = True
                break # from for-loop

        if False == found:
            print("ERROR: Tab window not found!")
            return # can't continue with this function                    
            
        #rb is for opening non-text files
        f = open(evidencePath, 'rb')
        pcap = dpkt.pcap.Reader(f)

        # For each packet in the pcap process the contents
        identifier = 0
        for timestamp, buf in pcap:

            """# Print out the timestamp in UTC
            print ("Timestamp" , str(datetime.datetime.utcfromtimestamp(timestamp)))"""
                    
            identifier = identifier + 1
            frameNumber  = identifier

            # Unpack the Ethernet frame (mac src/dst, ethertype)
            eth = dpkt.ethernet.Ethernet(buf)

            if eth.type == dpkt.ethernet.ETH_TYPE_IP:
                print("IP packet type detected. Extracting values...")
                #to contain your IP address in binary
                ip_hdr = eth.data
                ip     = eth.ip
                tcp    = ip.data
                    
                # Frame number (assumed to be a sequential number which
                # identifies a Ethernet entry within the PCAP)
                frameNumber  = identifier
                    
                #------------------------
                # Server to Web Client
                #------------------------
                src_ip_addr_bin = ip_hdr.src
                src_host_str = socket.inet_ntoa(src_ip_addr_bin)
                    
                if ip_hdr.p == dpkt.ip.IP_PROTO_TCP:
                    try:                               
                        #for server ip
                        http = dpkt.http.Response(tcp.data)
                        content_length = http.headers['content-length'] if 'content-length' in http.headers else ""
                        size = str(content_length)
                        print("Content length: ", size)
                        #protocol = protocol + (http.headers['transfer-encoding'] if 'transfer-encoding' in http.headers else "")
                                
                    except Exception:
                        print("Exception in Response direction")
                            
                else:
                    print("Protocol is not TCP")
                    
                print("Source host: ", src_host_str)
                    
                #------------------------
                # Web Client to Server
                #------------------------
                dst_ip_addr_bin = ip_hdr.dst
                dst_host_str = socket.inet_ntoa(dst_ip_addr_bin)
                    
                if ip_hdr.p == dpkt.ip.IP_PROTO_TCP:
                    try:      
                        http = dpkt.http.Request(tcp.data)
                            
                        #for web dns
                        host = http.headers['host'] if 'host' in http.headers else None
                        dst_host_str = dst_host_str + " [" + str(host) + "]"

                        #for server side, name of machine    
                        user_agent = http.headers['user-agent'] if 'user-agent' in http.headers else None
                        src_host_str = src_host_str + " [" + str(user_agent) + "]"
                            
                                
                    except Exception:
                            print("Exception in Request direction")
                            
                else: 
                    try:
                        src_host_str = src_host_str + " (Other)"

                    except Exception:
                        print("Exception in SSL web client to server direction")
                        
                print("Desintation host: ", dst_host_str)
                    
                #-----------------
                # Output to GUI
                #-----------------
                sequence = [str(frameNumber), str(src_host_str),str(dst_host_str)]
                pcapCredentialsTab.CredTabPanel.addCredDetails(window, sequence)    
                    
            else:
                print("Unsupported packet type. Values not extracted.")
        
            print ("\nPCAP extraction finished.\n")
        
        lock.release()

    def runFiles(lock):
        lock.acquire()
        global evidencePath
        # Find the window corresponding to the File tab so that we can
        # access it
        pageCount = mainFrame.auiNotebook.GetPageCount()
        found = False
        print("Page count: ", pageCount)
        #must initialize the page count on top so i can use here to match the text
        for i in range (0, pageCount): # 0 to pageCount - 1
            text = mainFrame.auiNotebook.GetPageText(i)
            print("Page ", i, ": ", text, ";")
            if text == "File":
                window = mainFrame.auiNotebook.GetPage(i)
                found = True
                break # from for-loop

        if False == found:
            print("ERROR: Tab window not found!")
            return # can't continue with this function                    
            
        #rb is for opening non-text files
        f = open(evidencePath, 'rb')
        pcap = dpkt.pcap.Reader(f)

        # For each packet in the pcap process the contents
        identifier = 0
        httpFileTransferCount = 0;
        for timestamp, buf in pcap:
            identifier = identifier + 1
            #line of text separation
            print("\n") 
            print("Identifier: ", identifier)
                
            #default values
            protocol    = "HTTP "
            fileExt         = ""
            fileSize        = ""
            timestamp   = ""
            fileName    = ""
            evidencePath = ""
                
            #Ethernet type code
            eth = dpkt.ethernet.Ethernet(buf)

            if eth.type == dpkt.ethernet.ETH_TYPE_IP:
                #to contain your IP address in binary
                ip_hdr = eth.data
                ip     = eth.ip
                tcp    = ip.data
                    
                #frameNumber is a sequential number
                #identifies an Ethernet entry within the PCAP
                frameNumber  = identifier
                    
                #--------------------------#
                #   Server to Web Client   #
                #--------------------------#
                src_ip_addr_bin = ip_hdr.src
                src_host_str = socket.inet_ntoa(src_ip_addr_bin)
                    
                if ip_hdr.p == dpkt.ip.IP_PROTO_TCP:
                    src_port = tcp.sport
                        
                    #if source port is 80 or 443 then i'm looking at a Response message
                    #from the server to the web client
                    if (80 == int(src_port)) and (len(tcp.data) > 0):
                        try:                               
                            http = dpkt.http.Response(tcp.data)
                            content_length = http.headers['content-length'] if 'content-length' in http.headers else ""
                            size = str(content_length)
                            protocol = protocol + (http.headers['transfer-encoding'] if 'transfer-encoding' in http.headers else "")
                        except Exception:
                            print("Exception in Response direction")
                                
                    # if SSL        
                    #https://dpkt.readthedocs.io/en/latest/_modules/dpkt/ssl.html
                    #https://gist.github.com/strizhechenko/3b70da47d317f8f8875d39edbfc5d7fc
                    #https://tools.ietf.org/html/rfc5246#section-7.4.2
                    #https://tls.ulfheim.net/
                    #https://tls.ulfheim.net/certificate.html
                    elif (443 == int(src_port)) and (len(tcp.data) > 0 ): 
                        try:
                            protocol = "TLS Certificate"
                                
                            tls = dpkt.ssl.TLS(tcp.data)
                            if len(tls.records) >= 1:
                                for i in range (0, len(tls.records)):
                                    handshake = dpkt.ssl.TLSHandshake(tls.records[i].data)
                                    if handshake.type == 11:
                                        certificateClassInst = handshake.data
                                        #certificate is str type TODO multiple certificates
                                        certificate = certificateClassInst.certificates[0] 
                                        data = certificate
                                            
                                        idx = 0
                                        lenData = len(data)
                                        print("Data length: " + str(lenData))
                                        found = False
                                        while (idx < (lenData - 2)):
                                            Byte1 = data[idx]
                                            Byte2 = data[idx + 1]
                                            print("Byte 1: " + str(hex(Byte1)) + " Byte 2: " + str(hex(Byte2)))

                                            #cert seq or cert info seq
                                            if (Byte1 == 0x30) and (Byte2 == 0x82): 
                                                inc = 4

                                            #iss seq
                                            elif (Byte1 == 0x30) and (Byte2 == 0x22): 
                                                inc = 2

                                            #subj seq
                                            elif (Byte1 == 0x30) and (Byte2 == 0x2b): 
                                                inc = 2

                                            #iss seq
                                            elif (Byte1 == 0x30) and (Byte2 == 0x4e): 
                                                inc = 2
                                            else:
                                                #length (+2 to include Byte1 and Byte2)
                                                inc = Byte2 + 2 
                                                    
                                            #safety check
                                            if inc == 0:
                                                print("byte sync lost")
                                                break #from while-loop
                                                
                                            #start of rdn seq - look for common name
                                            if (Byte1 == 0x30) and (Byte2 == 0x81): 
                                                print("start of rdn seq found")
                                                for i in range (idx +2, len(data) - 7):
                                                    Byte1 = data[i]
                                                    Byte2 = data[i + 1]
                                                    Byte5 = data[i + 4]
                                                    Byte6 = data[i + 5]
                                                    Byte7 = data[i + 6]
                                                    if (Byte1 == 0x30) and (Byte5 == 0x55) and (Byte6 == 0x04) and (Byte7 == 0x03):
                                                        print("common name found")
                                                        comNameLen = data[i + 8]
                                                        #i + 9 + comName gives us characters up to i + 9 + comName -1 !
                                                        comName = data[i + 9: i + 9 + comNameLen] 
                                                        print("Common name: " + str(comName))
                                                        src_host_str = src_host_str + " [" + str(comName) + "]"
                                                        found = True
                                                
                                            idx = idx + inc
                                            if True == found:
                                                break #from while-loop
                                                
                                        if False == found:
                                            print("common name not found")

                        except Exception:
                            print("Exception in SSL web server to client direction")
                            
                else:
                    print("Protocol is not TCP")
                    
                #--------------------------#
                #   Web Client to Server   #
                #--------------------------#
                dst_ip_addr_bin = ip_hdr.dst
                dst_host_str = socket.inet_ntoa(dst_ip_addr_bin)
                    
                if ip_hdr.p == dpkt.ip.IP_PROTO_TCP:
                    dst_port = tcp.dport
                        
                    #if destination port is 80 or 443 then i'm looking at a Request message
                    #from the web client to the server
                    #if HTTP
                    if (80 == int(dst_port)) and (len(tcp.data) > 0): 
                        try:      
                            http = dpkt.http.Request(tcp.data)
                                
                            host = http.headers['host'] if 'host' in http.headers else None
                            dst_host_str = dst_host_str + " [" + str(host) + "]"
                                
                            uri = http.uri
                            evidencePath = str(uri)
                            fileName = os.path.basename(evidencePath)
                            ext = os.path.splitext(fileName)[1][1:]
                                
                            user_agent = http.headers['user-agent'] if 'user-agent' in http.headers else None
                            src_host_str = src_host_str + " [" + str(user_agent) + "]"
                                
                            protocol = protocol + (http.headers['transfer-encoding'] if 'transfer-encoding' in http.headers else "")
                                
                            if fileName != "":
                                httpFileTransferCount = httpFileTransferCount + 1
                                
                        except Exception:
                            print("Exception in Request direction")
                                
                    #if SSL        
                    elif (443 == int(dst_port)) and (len(tcp.data) > 0 ): 
                        try:
                            src_host_str = src_host_str + " (Other)"
                            protocol = "TLS Certificate"
                                
                        except Exception:
                            print("Exception in SSL web client to server direction")
                         
                else:
                    print("Protocol is not TCP")
                        
                timestamp = ""
                                           
                #------------------------#
                #   Output to database   #
                #------------------------#
                #only show packets relating with file transfers (via port 80 or port 443)
                if (src_port == 80) or (src_port == 443) or (dst_port == 80) or (dst_port == 443): 
                    #TODO make more elegant
                    sequence = [str(frameNumber),str(evidencePath),str(src_host_str),str(src_port),str(dst_host_str),str(dst_port),str(protocol),str(fileName),str(fileExt),str(fileSize),str(timestamp)]
                    pcapFilesTab.FilesTabPanel.addPcapDetails(window, sequence) 
                    
            else:
                print("Unsupported packet type. Values not extracted.")

        lock.release()


   
    def onAddEvidence(self, event):
        """relating to extraction of values from PCAP file"""
        global caseDetails
        try:
            caseDetails                                                     
        except NameError:                                                   #if caseDetails not defined
            print("Case not opened")                                        
        else:                                                               #if caseDetails is defined
            openFileDialog = wx.FileDialog(self, "Open", "", "","*.pcap",     #creates a filedialog that only allow user to select .pcap files 
                                        wx.FD_OPEN | wx.FD_FILE_MUST_EXIST)
    
            openFileDialog.ShowModal()                         
            global caseDir, caseDbPath, evidencePath

            #evidencePath includes filename                                   
            evidencePath = openFileDialog.GetPath()

            # creating a lock 
            lock = threading.Lock()

            # creating thread 
            t1 = threading.Thread(target=mainFrame.runsessions, args=(lock,)) 
            t2 = threading.Thread(target=mainFrame.rundns, args=(lock,))
            t3 = threading.Thread(target=mainFrame.runCred, args=(lock,))
            t4 = threading.Thread(target=mainFrame.runFiles, args=(lock,))
  
            # starting thread 1 
            t1.start() 
            # starting thread 2 
            t2.start()
            #starting thread 3
            t3.start() 
            #starting thread 4
            t4.start()   

            # wait until thread 1 is completely executed 
            t1.join() 
            # wait until thread 2 is completely executed 
            t2.join()
            #wait until thread 3 is completely executed
            t3.join() 
            #wait until thread 4 is completely executed
            t4.join() 
    
            # both threads completely executed 
            print("Done!")     
            
            print ("\nPCAP extraction finished.\n")

        openFileDialog.Destroy() # close PCAP file
            

    def onQuit(self, event):  
        self.Close()
        self.Destroy()

    def onClearGUI(self, event):  
        print("Event handler 'onClearGUI' not implemented!")
        event.Skip()

    def onDeleteData(self, event):  
        print("Event handler 'onDeleteData' not implemented!")
        event.Skip()

    #end of menu functions

    #aui tab functions
    def checkOpenedTab(self, tabName):                     #check if tab is opened in aui
        openedTab = set(openTabs)
        if tabName not in openedTab:
            openTabs.append(tabName)
            return True
        else:
            return False

    def addAuiTab(self, tabName, evidenceDetails):
        global caseDir
        for x in caseDetails:
            caseDir = x[4]

        if tabName == "Summary":
            self.auiNotebook.AddPage(SummaryTab.TabPanel(self.auiNotebook, caseDetails, evidenceDetails), tabName, False, wx.NullBitmap)

        if tabName == "File":
            self._dialog = wx.ProgressDialog("Loading", "Loading {tabName}".format(tabName=tabName), 100)  #create loading dialog
            LoadingDialog(self._dialog)                                                                    #start loading 
            self.auiNotebook.AddPage(pcapFilesTab.FilesTabPanel(self.auiNotebook, tabName, caseDir), tabName, False, wx.NullBitmap) #calls and open a aui tab from DeletedFilesTab.py
            LoadingDialog.endLoadingDialog(self)


        if tabName == "Images":
            self._dialog = wx.ProgressDialog("Loading", "Loading {tabName}".format(tabName=tabName), 100)  #create loading dialog
            LoadingDialog(self._dialog)                                                                    #start loading 
            self.auiNotebook.AddPage(ImagesTab.TabPanel(self.auiNotebook, tabName, caseDir), tabName, False, wx.NullBitmap) #calls and open a aui tab from DeletedFilesTab.py
            LoadingDialog.endLoadingDialog(self)    

        if tabName == "Sessions":
            self._dialog = wx.ProgressDialog("Loading", "Loading {tabName}".format(tabName=tabName), 100)  #create loading dialog
            LoadingDialog(self._dialog)                                                                    #start loading 
            self.auiNotebook.AddPage(pcapSessionsTab.SessionsTabPanel(self.auiNotebook, caseDir), tabName, False, wx.NullBitmap) #calls and open a aui tab from DeletedFilesTab.py
            LoadingDialog.endLoadingDialog(self)    

        if tabName == "DNS":
            self._dialog = wx.ProgressDialog("Loading", "Loading {tabName}".format(tabName=tabName), 100)  #create loading dialog
            LoadingDialog(self._dialog)                                                                    #start loading 
            self.auiNotebook.AddPage(pcapDNSTab.DNSTabPanel(self.auiNotebook, caseDir), tabName, False, wx.NullBitmap) #calls and open a aui tab from DeletedFilesTab.py
            LoadingDialog.endLoadingDialog(self)    

        if tabName == "Credentials":
            self._dialog = wx.ProgressDialog("Loading", "Loading {tabName}".format(tabName=tabName), 100)  #create loading dialog
            LoadingDialog(self._dialog)                                                                    #start loading 
            self.auiNotebook.AddPage(pcapCredentialsTab.CredTabPanel(self.auiNotebook, tabName, caseDir), tabName, False, wx.NullBitmap) #calls and open a aui tab from DeletedFilesTab.py
            LoadingDialog.endLoadingDialog(self)    

        if tabName == "Bookmarks":
            self._dialog = wx.ProgressDialog("Loading", "Loading {tabName}".format(tabName=tabName), 100)
            LoadingDialog(self._dialog)
            self.auiNotebook.AddPage(AnalyzedDataTab.TabPanel(self.auiNotebook, tabName, evidenceDetails, caseDir, caseDbPath), tabName, False, wx.NullBitmap)  #calls and open a aui tab from SummaryTab.py
            LoadingDialog.endLoadingDialog(self)


        # TODO un-comment-out the following code once evidence exists properly
        # note: commented-out to allow File tab to be tested before database code added
        """for x in evidenceDetails:                  
            evidenceDbConn = connectdb.create_connection(x[2])                      #connects to tsk database
            evidenceDbInfo = connectdb.select_image_info(evidenceDbConn)            #get name, size and md5 from tsk database
            evidencePart  = connectdb.select_image_partitions(evidenceDbConn)       #get partition info from tsk database
            count = 0
            for i in evidencePart:
                count += 1
                if tabName == "Vol{count} {desc}: {start}-{end})".format(count=count, desc=str(i[2]), start=str(i[0]), end=str(i[1])):
                    self._dialog = wx.ProgressDialog("Loading", "Loading {tabName}".format(tabName=tabName), 100)
                    LoadingDialog(self._dialog)
                    self.auiNotebook.AddPage(AnalyzedDataTab.TabPanel(self.auiNotebook, tabName, evidenceDetails, caseDir, caseDbPath), tabName, False, wx.NullBitmap)
                    LoadingDialog.endLoadingDialog(self)"""
                
    def onItemSel(self, event):  
        temp = event.GetItem()          #gets selected item from treectrl
        tabName = self.tree_ctrl_1.GetItemText(temp)    
        print("{name} selected".format(name=tabName))
        
        if self.checkOpenedTab(tabName) == True:        #check if selected item is open 
            evidenceDetails = 0 # TODO remove this line when database code has been added
            self.addAuiTab(tabName, evidenceDetails)    #open aui tab
        else: 
            print('Tab already open')
            
        # TODO un-comment-out the following code (and remove lines above) once evidence exists properly
        # note: commented-out to allow File tab to be tested before database code added
        """try:
            caseDetails                 #checks if caseDetails is defined
        except:                         #if not defined
            print("Case not opened")
        else:                           #if defined
            try:                    
                evidenceDetails
            except:
                print("No evidence found")
            else:
                if self.checkOpenedTab(tabName) == True:        #check if selected item is open 
                    self.addAuiTab(tabName, evidenceDetails)    #open aui tab
                else: 
                    print('Tab already open')"""


    def onAuiClose(self, event):
        temp = event.GetSelection()
        tabName = self.auiNotebook.GetPageText(temp)
        #self.auiNotebook.RemovePage(temp)          #mac
        print("Closing " + tabName)
        openTabs.remove(tabName)                    #remove closed tab from openTabs
    
    def onSearchBtn(self, event):
        try:
            caseDetails
        except:
            print("Case not open")
        else:
            dlg = search.searchDialog(None)         #calls searchDialog() from search.py
            dlg.Center()
            dlg.ShowModal()
            searchItem = dlg.searchItems()          #calls searchItem() to get search and search option

            searchReturn = []
            if searchItem[1] == "Normal Search":
                for x in evidenceDetails:
                    conn = connectdb.create_connection(x[2])                            #connect to tsk database
                    searchResults = connectdb.search_file_name(conn, searchItem[0])     #search in tsk database
                    if searchResults != []:
                        for i in searchResults:
                            i = i + (x[1],)                                             #adds image location to end of result
                            searchReturn.append(i)                                      #append each result

                self._dialog = wx.ProgressDialog("Search", "Searching for {val}".format(val=searchItem[0]), 100)
                LoadingDialog(self._dialog)
                self.auiNotebook.AddPage(searchTab.searchTabPanel(self.auiNotebook, searchReturn, caseDir), "Search ("+searchItem[0]+")", False, wx.NullBitmap) #call and add searchTab aui page
                LoadingDialog.endLoadingDialog(self)
            else:
                print("Regular Expression")

            dlg.Destroy()
        

class LoadingDialog():
    def __init__(self, _dialog):
        self._dialog = _dialog
        self._dialog.Center()
        self._dialog.Pulse()
        self.run()
     
    def run(self):
        count = 0
        while True:
            self._dialog.Update(count)
            if count == 100:
                break
            count += 2
        
    def endLoadingDialog(self):
        self._dialog.Destroy()

class MyApp(wx.App):
    def OnInit(self):
        self.ForensicPi = mainFrame(None)
        self.SetTopWindow(self.ForensicPi)
        self.ForensicPi.Show()
        self.ForensicPi.Center()        
        return True
    

# end of class MyApp

if __name__ == "__main__":
    forensicPi = MyApp(0)
    forensicPi.MainLoop()
